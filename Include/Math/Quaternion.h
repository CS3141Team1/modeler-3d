#pragma once

#include <cmath>

#include "Types.h"
#include "Vector3.h"
#include "Vector4.h"
#include "Matrix4.h"

namespace Core
{

namespace Math
{

/**
 * Quaternion representation
 *
 * @author Michael Conard
 * @tparam Type the type for the values in the quaternion, should be float or double
 */
template <typename Type>
struct Quaternion
{
	//Values: x,y,z vector portion, w scalar
	Type X, Y, Z, W;

	//Declarations for constant quats
	static const Quaternion<Type> Identity;

	//Constructors
	/**
	 * Default constructor for quaternion.
	 *
	 * @return The identity quaternion
	 */
	Quaternion() : X(0), Y(0), Z(0), W(1) {}
	/**
	 * Single type, four value constructor for quaternion
	 *
	 * @param x
	 * @param y
	 * @param z
	 * @paramw
	 * @return Quaternion(x,y,z,w) where w is scalar
	 */
	Quaternion(const Type& x, const Type& y, const Type& z, const Type& w) : X(x), Y(y), Z(z), W(w) {}
	/**
	 * Variable type, four value constructor for quaternion
	 *
	 * @param x of Type2
	 * @param y of Type3
	 * @param z of Type4
	 * @param w of Type5
	 * @return Quaternion(x,y,z,w) where w is scalar
	 */
	template <typename Type2, typename Type3, typename Type4, typename Type5>
	Quaternion(const Type2& x, const Type3& y, const Type4& z, const Type5& w) : X(x), Y(y), Z(z), W(w) {}
	/**
	 * Single type, vector plus scalar constructor for quaternion
	 *
	 * @param v Vector3<Type>
	 * @param w the scalar
	 * @return Quaternion(v,w) where v is x,y,z and w is scalar
	 */
	Quaternion(const Vector3<Type>& v, const Type& s)
	{
		X = v[0];
		Y = v[1];
		Z = v[2];
		W = s;
	}

	/**
	 * Returns a quaternion by axis angle
	 *
	 * @param v Vector3<Type> the axis
	 * @param w the angle in radians
	 * @return A quaternion generated by axis angle
	 */
	static Quaternion<Type> AxisAngle(const Vector3<Type>& v, const Type& w)
	{
		Quaternion<Type> ret;

		Type s = std::sin(w/2.0);
		Type c = std::cos(w/2.0);

		ret.W = c;
		ret.X = v[0] * s;
		ret.Y = v[1] * s;
		ret.Z = v[2] * s;

		return ret;
	}

	/**
	 * Returns a quaternion from an euler format with z,y,x order
	 * NOTE: vector should still be formatted x,y,z
	 *
	 * @param v Vector3<Type> an euler format z,y,x
	 * @return Quaternion<Type> the quaternion conversion
	 */
	static Quaternion<Type> FromEuler(const Vector3<Type>& v)
	{
		Quaternion<Type> fromEuler;
		Quaternion<Type> fromX = Quaternion::AxisAngle(Vector3<Type>(1,0,0), v[0]);
		Quaternion<Type> fromY = Quaternion::AxisAngle(Vector3<Type>(0,1,0), v[1]);
		Quaternion<Type> fromZ = Quaternion::AxisAngle(Vector3<Type>(0,0,1), v[2]);

		fromEuler = fromZ * fromY * fromX;

		return fromEuler;
	}

	/**
	 * Returns an z,y,x order euler format from quaternion
	 *
	 * @param q Quaternion<Type> the quaternion to convert
	 * @return Vector3<Type> The z,y,x order euler form conversion
	 */
	static Vector3<Type> ToEuler(const Quaternion<Type>& q)
	{
		Vector3<Type> ret;
		ret[0] = std::atan2(2*(q.Y*q.Z + q.W*q.X), q.W*q.W - q.X*q.X - q.Y*q.Y + q.Z*q.Z);
		ret[1] = std::asin(-2*(q.X*q.Z - q.W*q.Y));
		ret[2] = std::atan2(2*(q.X*q.Y + q.W*q.Z),q.W*q.W + q.X*q.X - q.Y*q.Y - q.Z*q.Z);
		return ret;
	}

	/**
	 * Returns a roation matrix from quaternion
	 *
	 * @param q Quaternion<Type> the quaternion to convert
	 * @return Matrix3<Type> The rotation matrix of q
	 */
	static Matrix4<Type> ToRotationMatrix(const Quaternion<Type>& q)
	{
		Matrix4<Type> ret;
		Type y2 = q.Y * q.Y;
		Type x2 = q.X * q.X;
		Type z2 = q.Z * q.Z;

		ret[0][0] = 1.0 - 2.0 * y2 - 2.0 * z2;
		ret[1][0] = 2.0 * q.X * q.Y - 2.0 * q.Z * q.W;
		ret[2][0] = 2.0 * q.X * q.Z + 2.0 * q.Y * q.W;
		ret[0][1] = 2.0 * q.X * q.Y + 2.0 * q.Z * q.W;
		ret[1][1] = 1.0 - 2.0 * x2 - 2.0 * z2;
		ret[2][1] = 2.0 * q.Y * q.Z - 2.0 * q.X * q.W;
		ret[0][2] = 2.0 * q.X * q.Z - 2.0 * q.Y * q.W;
		ret[1][2] = 2.0 * q.Y * q.Z + 2.0 * q.X * q.W;
		ret[2][2] = 1.0 - 2.0 * x2 - 2.0 * y2;
		return ret;
	}

	//Array access overload
	const Type& operator[](uint i) const { return (&X)[i]; }
	Type& operator[](uint i) { return (&X)[i]; }

	//Assigment
    Quaternion<Type>& operator=(const Quaternion q)
    {
    	X = q.X;
    	Y = q.Y;
    	Z = q.Z;
    	W = q.W;
    	return *this;
    }

    //Negation overload
    Quaternion<Type> operator-() const { return Quaternion<Type>(-X,-Y,-Z,-W); }

    //Equality overloads
    bool operator==(const Quaternion<Type>& q) { return X == q.X && Y == q.Y && Z == q.Z && W == q.W; }
    bool operator!=(const Quaternion<Type>& q) { return X != q.X || Y != q.Y || Z != q.Z || W != q.W; }

    //Multiply and divide equals overloads
    Quaternion<Type>& operator*=(const Quaternion<Type>& q)
    {
    	Quaternion<Type> copy = *this;

    	copy.W = W * q.W - X * q.X - Y * q.Y - Z * q.Z;
    	copy.X = W * q.X + X * q.W + Y * q.Z - Z * q.Y;
    	copy.Y = W * q.Y + Y * q.W + Z * q.X - X * q.Z;
    	copy.Z = W * q.Z + Z * q.W + X * q.Y - Y * q.X;

    	*this = copy;

    	return *this;
    }

    Quaternion<Type>& operator*=(const Type& s)
    {
    	W *= s;
    	X *= s;
    	Y *= s;
    	Z *= s;

    	return *this;
    }

    Quaternion<Type>& operator/=(const Quaternion<Type>& q)
    {
    	(*this) *= Inverse(q);

    	return *this;
    }

    Quaternion<Type>& operator/=(const Type& s)
    {
    	W /= s;
    	X /= s;
    	Y /= s;
    	Z /= s;

    	return *this;
    }
};

//Multiplying overloads
template <typename Type, typename Type2>
Quaternion<Type> operator*(Quaternion<Type> q, const Quaternion<Type2>& r)
{
	q *= r;
	return q;
}

template <typename Type, typename Type2>
Quaternion<Type> operator*(Quaternion<Type> q, const Vector3<Type2>& v)
{
	Quaternion<Type> r(v[0],v[1],v[2],0);
	q *= r;
	return q;
}

template <typename Type, typename Type2>
Quaternion<Type> operator*(Quaternion<Type> q, const Type2& s)
{
	q.W *= s;
	q.X *= s;
	q.Y *= s;
	q.Z *= s;

	return q;
}

//Divide overloads
template <typename Type, typename Type2>
Quaternion<Type> operator/(Quaternion<Type> q, const Type2& s)
{
	q.W /= s;
	q.X /= s;
	q.Y /= s;
	q.Z /= s;

	return q;
}

template <typename Type, typename Type2>
Quaternion<Type> operator/(const Type2& s, Quaternion<Type> q)
{
	Quaternion<Type> inverse = Inverse(q);
	inverse.W *= s;
	inverse.X *= s;
	inverse.Y *= s;
	inverse.Z *= s;

	return inverse;
}

/**
 * Returns the length of a Quaternion
 *
 * @param q A Quaternion<Type>
 * @return Length of the Quaternion of type Type
 */
template <typename Type>
Type Length(const Quaternion<Type>& q)
{
    return std::sqrt((q.X * q.X) + (q.Y * q.Y) + (q.Z * q.Z) + (q.W * q.W));
}

/**
 * Returns the length squared of a Quaternion
 *
 * @param v A Quaternion<Type>
 * @return Length squared of the Quaternion of type Type
 */
template <typename Type>
Type LengthSq(const Quaternion<Type>& q)
{
    return (q.X * q.X) + (q.Y * q.Y) + (q.Z * q.Z) + (q.W * q.W);
}

/**
 * Returns the conjugate of a Quaternion
 *
 * @param q A Quaternion<Type>
 * @return Quaternion<Type> The conjugate Quaternion
 */
template <typename Type>
Quaternion<Type> Conjugate(Quaternion<Type>& q)
{
	Quaternion<Type> conjugate;
	conjugate.W = q.W;
	conjugate.X = -q.X;
	conjugate.Y = -q.Y;
	conjugate.Z = -q.Z;

	return conjugate;
}

/**
 * Returns the inverse of a Quaternion
 *
 * @param q A Quaternion<Type>
 * @return Quaternion<Type> The inverse Quaternion
 */
template <typename Type>
Quaternion<Type> Inverse(Quaternion<Type>& q)
{
	Quaternion<Type> inverse;

	inverse = Conjugate(q);

	inverse /= LengthSq(q);

	return inverse;
}

/**
 * Returns the unit vector of a Quaternion
 *
 * @param q A Quaternion<Type>
 * @return Quaternion<Type> The normalized Quaternion
 */
template <typename Type>
Quaternion<Type> Normalize(const Quaternion<Type> q)
{
    Type len = LengthSq(q);

    if (len == 0.0)
    {
        return Quaternion<Type>(0,0,0,0);
    }
    else
    {
        return q / std::sqrt(len);
    }
}

//To string
template <typename Type>
std::ostream& operator<<(std::ostream& out, const Quaternion<Type>& q)
{
    return out << "(" << q.X << ", " << q.Y << ", " << q.Z << ", " << q.W << ")";
}

template <typename Type>
std::string ToString(Quaternion<Type> q) {
	std::string ret = "";
	ret += "(" + std::to_string(q.X) + ", " + std::to_string(q.Y) + ", " + std::to_string(q.Z) + ", " + std::to_string(q.W) + ")";
	return ret;
}

//Identity quaternion
template <typename Type> const Quaternion<Type> Quaternion<Type>::Identity;

//Type definitions for prettier code and less typing
typedef Quaternion<float32> Quaternionf;
typedef Quaternion<float64> Quaterniond;

}

}
